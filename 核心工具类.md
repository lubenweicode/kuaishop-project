# 核心工具类说明文档

# JWT令牌工具类

## 一、工具类作用

JwtUtil是项目中的JWT令牌工具类，主要用于处理用户的登陆后的身份认证。

它的核心功能：

- 生成登录令牌(Token)
- 校验Token是否合法、过期、被篡改
- 从Token中解析出用户ID、自定义信息
- 从请求头中自动提取并解析Token。

在项目中，它是登录、鉴权、接口安全的核心工具。

## 二、用到的技术与依赖

- JJWT(Java JWTT库)：生成、解析、校验JWT
- HMAC-SHA256：对称加密签名算法
- Spring @Value：从配置文件中读取密钥、过期时间
- Lombok @Slf4j：打印日志
- HttpServletRequest：从请求头获取Token

## 三、核心字段说明

```java
// 从配置文件注入JWT过期时间（毫秒）
@Value("${jwt.expire}")
private Long jwtExpire;

// 从配置文件注入JWT签名密钥
@Value("${jwt.sign-key}")
private String jwtSignKey;
```

`jwtExpire`：控制登录态多久失效

`jwtSignKey`：服务端秘钥，**不能泄露**，否则 Token 可被伪造

```yml
jwt:
  expire: 604800 # 过期时间
  sign-key: ****   # 密钥（≥32字符）
```

## 四、核心代码

### 1.`generateToken(String userId,Map<String,Object> claims)`

**作用：生成JWT令牌**

流程：

1. 根据密钥生成加密钥匙
2. 设置过期时间
3. 把userId放到subject中
4. 放入自定义信息(角色、权限等)
5. 使用SHA256签名
6. 返回最终Token

| 载荷类型       | 存储位置 / 方法             | 用途           | 示例                                   | 获取规则     |
| -------------- | --------------------------- | -------------- | -------------------------------------- | ------------ |
| **标准载荷**   | JWT 内置字段（setXXX 方法） | 通用核心信息   | 用户 ID（Subject）、签发时间、过期时间 | getSubject() |
| **自定义载荷** | addClaims (Map) 存入键值对  | 业务个性化信息 | 角色、权限、用户名、用户类型           | get(key)     |

```java
/**
     * 生成JWT Token
     *
     * @param userId 用户ID（自定义有效载荷）
     * @param claims 自定义扩展载荷（如角色、权限等）
     * @return 生成的token字符串
     */
    public String generateToken(String userId, Map<String, Object> claims) {
        // 创建签名密钥（确保密钥长度足够，不足时自动补全）
        SecretKey secretKey = Keys.hmacShaKeyFor(jwtSignKey.getBytes(StandardCharsets.UTF_8));

        // 计算token过期时间
        Date expireDate = new Date(System.currentTimeMillis() + jwtExpire);

        // 构建并生成token
        return Jwts.builder()
                // 自定义载荷（必选：用户ID）
                .setSubject(userId)
                // 自定义扩展载荷
                .addClaims(claims)
                // 签发时间
                .setIssuedAt(new Date())
                // 过期时间
                .setExpiration(expireDate)
                // 签名算法和密钥
                .signWith(secretKey, SignatureAlgorithm.HS256)
                // 构建token
                .compact();
    }
```

### 2.`parseToken(String token)`

**作用：解析Token，获取里面的用户信息**

- 验证签名是否正确
- 验证是否过期
- 解析出所有载荷(Claims)

```java
    /**
     * 解析Token，获取JWT的Payload部分
     *
     * @param token JWT token字符串
     * @return Claims对象（包含所有载荷信息）
     * @throws ExpiredJwtException      token过期
     * @throws MalformedJwtException    token格式错误
     * @throws SignatureException       签名验证失败
     * @throws IllegalArgumentException token为空或无效
     */
    public Claims parseToken(String token) {
        SecretKey secretKey = Keys.hmacShaKeyFor(jwtSignKey.getBytes(StandardCharsets.UTF_8));

        // 解析Token
        return Jwts.parserBuilder() // 创建Token解析器
                .setSigningKey(secretKey) // 设置密钥
                .build() // 创建Token解析器
                .parseClaimsJws(token) // 解析Token
                .getBody(); // 获取Payload部分
    }
```

### 3.`validateToken(String token)`

**作用：统一判断Token是否有效**

会捕获这些异常：

- Token过期
- 格式错误
- 签名不对
- 内容非法

```java
/**
     * 验证Token是否有效
     *
     * @param token JWT token字符串
     * @return true：有效；false：无效
     */
    public boolean validateToken(String token) {
        try {
            log.info("正在验证Token：{}", token);
            parseToken(token);
            return true;
        } catch (ExpiredJwtException e) { // token过期异常
            log.error("Token已过期：{}", e.getMessage());
        } catch (MalformedJwtException e) { // token格式错误异常
            log.error("Token格式错误：{}", e.getMessage());
        } catch (SignatureException e) { // 签名验证失败异常
            log.error("Token签名验证失败：{}", e.getMessage());
        } catch (IllegalArgumentException e) { // token为空或无效异常
            log.error("Token为空或无效：{}", e.getMessage());
        } catch (Exception e) { // 其他异常
            log.error("Token验证异常：{}", e.getMessage(), e);
        }
        return false;
    }
```

### 4.`getUserIdFromToken(String token)`

**作用：从Token里拿出用户ID**

登录后的接口，请求头携带用户的Token，通过这个Token获取userId，不需要传userId。

```java
/**
     * 从Token中获取用户ID
     *
     * @param token JWT token字符串
     * @return 用户ID
     */
    public String getUserIdFromToken(String token) {
        try {
            Claims claims = parseToken(token);
            String userId = claims.getSubject();
            // 校验userId是否为空
            return userId == null || userId.isEmpty() ? null : userId;
        } catch (Exception e) {
            log.error("从Token中获取用户ID异常：{}", e.getMessage(), e);
            return null;
        }
    }
```

### 5.`getClaimFromToken(String token, String key)`

**作用：从Token中获取自定义扩展载荷**

使用泛型方法按Key精准获取，避免强转的麻烦。

```java
/**
     * 从Token中获取自定义扩展载荷
     *
     * @param token JWT token字符串
     * @param key   载荷key
     * @param <T>   载荷类型
     * @return 载荷值
     */
    public <T> T getClaimFromToken(String token, String key) {
        Claims claims = parseToken(token);
        return (T) claims.get(key);
    }
```

### 6.`getRemainingTime(String token)`

**作用：获取Token剩余过期时间**

```java
/**
     * 获取Token剩余过期时间（毫秒）
     *
     * @param token JWT token字符串
     * @return 剩余时间（负数表示已过期）
     */
    public long getRemainingTime(String token) {
        Claims claims = parseToken(token);
        Date expireDate = claims.getExpiration();
        return expireDate.getTime() - System.currentTimeMillis();
    }
```

# SHA256加密工具类

## 一、工具类作用

Sha256Util是项目中的SHA256哈希加密工具类，主要用于敏感信息(如用户密码)的加密与验证

它的核心功能：

- 生成16位随机盐值，提升加密安全性
- 纯文本SHA256加密、带盐值SHA256加密（推荐）
- 验证原始文本与加密文本是否匹配（支持盐值校验）
- 字节数组与16进制字符串的转换

在项目中，它是密码加密、敏感信息脱敏的核心工具。

## 二、用到的技术与依赖

- Java MessageDigest：原生加密API，实现SHA-256哈希算法
- SecureRandom：安全随机数生成器，生成随机盐值
- StandardCharsets：固定字符编码，避免加密乱码
- 无第三方依赖：基于JDK原生API实现，无需额外引入依赖

## 三、核心字段说明

```java
// 加密算法名称
private static final String ALGORITHM = "SHA-256";
```

`ALGORITHM`：指定加密算法为 SHA-256，固定值不可修改

## 四、核心代码

### 1.`generateSalt()`

**作用：生成 16 位随机盐值**

流程：

1. 创建安全随机数生成器
2. 生成16字节随机字节数组
3. 转换为16进制字符串返回

盐值作用：

- 防彩虹表破解：同一个明文+不同颜值 = 不同密文。
- 提升加密安全性：即使密码简单，加密后也无法通过彩虹表匹配。

```java
/**
 * 生成随机盐值（16位）
 *
 * @return 16进制字符串格式的盐值
 */
public static String generateSalt() {
    SecureRandom random = new SecureRandom();
    byte[] salt = new byte[16];
    random.nextBytes(salt);
    return bytesToHex(salt);
}
```

### 2.`encrypt(String text,String salt)`

作用：带盐值SHA256加密

流程：

1. 获取SHA-256加密摘要器
2. 重置摘要器避免累计加密结果
3. 拼接明文+盐值
4. UTF-8编码为字节数组，执行哈希加密
5. 加密后的字节数组转换为16进制字符串返回

```java
    /**
     * SHA256带盐值加密（推荐用于密码加密）
     *
     * @param text 需要加密的文本
     * @param salt 盐值（null则不使用盐值）
     * @return 加密后的16进制字符串
     */
    public static String encrypt(String text, String salt) {
        try {
            // 创建MessageDigest对象
            MessageDigest digest = MessageDigest.getInstance(ALGORITHM);
            // 重置MessageDigest对象
            digest.reset();
            // 拼接盐值（如果有）
            String content = salt == null ? text : text + salt;
            // 执行加密 
            byte[] bytes = digest.digest(text.getBytes(StandardCharsets.UTF_8));
            byte[] hash = digest.digest(bytes);
            // 转换为16进制字符串
            return bytesToHex(hash);
        } catch (NoSuchAlgorithmException e) {
            throw new RuntimeException("SHA256加密算法不存在", e);
        }
    }
```

### 3.`bytesToHex(byte[] bytes)`

作用：将字节数组转换为16进制字符串

核心逻辑：

- 遍历字节数组，逐个转换为2位16进制字符串
- 不足2位补0，保证SHA256加密后固定64位字符串长度

```java
/**
 * 将字节数组转换为16进制字符串
 *
 * @param bytes 字节数组
 * @return 16进制字符串
 */
private static String bytesToHex(byte[] bytes) {
    StringBuilder hexString = new StringBuilder();
    for (byte b : bytes) {
        String hex = Integer.toHexString(0xff & b);
        if (hex.length() == 1) {
            hexString.append('0');
        }
        hexString.append(hex);
    }
    return hexString.toString();
}
```

# 日期时间工具类

## 一、工具类作用

DateUtil是项目中的日期时间处理工具类，主要解决Java中Date与字符串的格式转换问题，适配业务中多种日志格式解析需求。

它的核心功能：

- 日期字符串（yyyy-MM-dd）转Date对象
- 日期时间字符串转Date对象（兼容两种格式：标准格式+英文本地化格式）
- Date对象转标准日期时间字符串（yyyy-MM-dd HH:mm:ss）
- 统一的异常处理与日志记录，明确提示格式错误

在项目中，它是订单时间、秒杀时间、用户操作时间等场景的核心转换工具。

## 二、用到的技术与依赖

- Java 8 Time API：LocalDate/LocalDateTime/ZonedDateTime，解决传统Date的线程安全问题
- DateTimeFormatter：线程安全的日期格式化器（替代SimpleDateFormat）
- ZoneId：时区处理，保证不同时区下时间转换的准确性
- Lombok @Slf4j：简化日志记录，替代手动创建Logger对象
- 无第三方依赖：基于JDK8+原生API实现，无需额外引入依赖

## 三、核心字段说明

```java
// 日期格式（yyyy-MM-dd）
public static final DateTimeFormatter DATE_FORMAT = DateTimeFormatter.ofPattern("yyyy-MM-dd");
// 日期时间格式（yyyy-MM-dd HH:mm:ss）
public static final DateTimeFormatter DATETIME_FORMAT = DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss");
// 英文本地化日期格式（适配 Tue Feb 10 10:00:00 CST 2026）
private static final DateTimeFormatter EN_LOCAL_DATETIME_FORMAT = DateTimeFormatter.ofPattern("EEE MMM dd HH:mm:ss zzz yyyy", Locale.US);
```

`DATE_FORMAT`：固定日期格式，用于纯日期字符串转换

`DATETIME_FORMAT`：标准日期时间格式，项目默认输出 / 解析格式

`EN_LOCAL_DATETIME_FORMAT`：兼容英文环境的日期格式，解决第三方接口返回特殊时间格式的解析问题

## 四、核心代码

### 1.`strToDate(String dateStr)`

**作用：日期字符串（yyyy-MM-dd）转 Date 对象**

流程：

1. 校验入参：日期字符串为空则抛出异常（拒绝返回 null）
2. 解析字符串为 LocalDate（Java8 新日期类型）
3. 转换为系统默认时区的 Instant
4. 最终转为 Date 对象返回

核心特点：

- 拒绝返回 null，通过异常让调用方明确感知错误
- 用 @Slf4j 记录错误日志，便于问题排查

```java
/**
     * 日期字符串（yyyy-MM-dd）转 Date
     *
     * @param dateStr 日期字符串（如：2026-01-28）
     * @return Date 类型
     * @throws IllegalArgumentException 日期字符串为空或格式不匹配时抛出异常（不再返回null）
     */
    public static Date strToDate(String dateStr) {
        if (dateStr == null || dateStr.trim().isEmpty()) {
            throw new IllegalArgumentException("日期字符串不能为空");
        }
        try {
            // 先转 LocalDate → 再转 Date
            LocalDate localDate = LocalDate.parse(dateStr.trim(), DATE_FORMAT);
            return Date.from(localDate.atStartOfDay(ZoneId.systemDefault()).toInstant());
        } catch (DateTimeParseException e) {
           log.info("日期格式错误，期望格式：yyyy-MM-dd HH:mm:ss，实际值：{}", dateStr);
           throw new IllegalArgumentException("日期格式错误，期望格式：yyyy-MM-dd HH:mm:ss", e);
        }
    }
```

### 2.`strToDateTime(String datetimeStr)`

**作用：日期时间字符串转 Date 对象（兼容两种格式）**

核心逻辑：

1. 优先解析标准格式（yyyy-MM-dd HH:mm:ss）
2. 解析失败则兼容解析英文本地化格式（Tue Feb 10 10:00:00 CST 2026）
3. 两种格式都失败则抛出明确异常，记录详细日志

关键解决的问题：

- 第三方接口 / 外部系统返回非标准日期格式时的解析兼容
- 指定 Locale.US 避免中文环境解析英文月份 / 星期失败

```java
/**
 * 日期时间字符串转 Date（兼容两种格式）
 * 1. 优先解析：yyyy-MM-dd HH:mm:ss（你的期望格式）
 * 2. 兼容解析：Tue Feb 10 10:00:00 CST 2026（你的实际传入格式）
 *
 * @param datetimeStr 日期时间字符串
 * @return Date 类型
 * @throws IllegalArgumentException 日期字符串为空或两种格式都不匹配时抛出异常（不再返回null）
 */
public static Date strToDateTime(String datetimeStr) {
    if (datetimeStr == null || datetimeStr.trim().isEmpty()) {
        throw new IllegalArgumentException("日期时间字符串不能为空");
    }
    // 1. 先尝试解析标准格式（yyyy-MM-dd HH:mm:ss）
    try {
        LocalDateTime localDateTime = LocalDateTime.parse(datetimeStr.trim(), DATETIME_FORMAT);
        return Date.from(localDateTime.atZone(ZoneId.systemDefault()).toInstant());
    } catch (DateTimeParseException e1) {
        // 2. 标准格式解析失败，尝试解析英文本地化格式
        try {
            ZonedDateTime zonedDateTime = ZonedDateTime.parse(datetimeStr.trim(), EN_LOCAL_DATETIME_FORMAT);
            return Date.from(zonedDateTime.withZoneSameInstant(ZoneId.systemDefault()).toInstant());
        } catch (DateTimeParseException e2) {
            log.info("日期格式错误，期望格式：yyyy-MM-dd HH:mm:ss，实际值：{}", datetimeStr);
            throw new IllegalArgumentException("日期格式错误，期望格式：yyyy-MM-dd HH:mm:ss", e2);
        }
    }
}
```

### 3.`formatDateTime(Date date)`

**作用：Date 对象转标准日期时间字符串（yyyy-MM-dd HH:mm:ss）**

核心改进：

- 修复返回值类型（从 Object 改为 String），直接返回格式化结果
- 校验入参非空，避免空指针异常
- 基于 Java8 Time API 转换，线程安全

```java
/**
 * Date 转 日期时间字符串（yyyy-MM-dd HH:mm:ss）
 *
 * @param date 日期对象
 * @return 格式化后的日期时间字符串
 * @throws IllegalArgumentException 传入Date为null时抛出异常
 */
public static String formatDateTime(Date date) { // 修复返回值：从Object改为String，直接返回格式化结果
    if (date == null) {
        throw new IllegalArgumentException("待格式化的日期对象不能为空");
    }
    LocalDateTime localDateTime = date.toInstant().atZone(ZoneId.systemDefault()).toLocalDateTime();
    return DATETIME_FORMAT.format(localDateTime);
}
```

